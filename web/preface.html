<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">

<html>

	<head>
		<meta http-equiv="content-type" content="text/html;charset=iso-8859-1">
		<link title="David R. Hanson" href="http://drh.home.dyndns.org" rev="made">
		<link href="style.css" rel="stylesheet" type="text/css" media="all">
		<title>Preface: A Retargetable C Compiler</title>
	</head>

	<body>
		<p><span class="banner"><a href="http://www.cs.princeton.edu">Princeton CS</a> &raquo; <a href="http://www.cs.princeton.edu/software">Software</a> &raquo; <a href="http://www.cs.princeton.edu/software/lcc/">lcc, A Retargetable C Compiler</a> &raquo; Preface</span></p>
		<h1>A Retargetable C Compiler: Design and Implementation</h1>
		<h1>Preface</h1>
		<p>The compiler is the linchpin of the programmer&rsquo;s toolbox. Working programmers use compilers every day and count heavily on their correctness and reliability. A compiler must accept the standard definition of the programming language so that source code will be portable across platforms. A compiler must generate efficient object code. Perhaps more importantly, a compiler must generate correct object code; an application is only as reliable as the compiler that compiled it.</p>
		<p>A compiler is itself a large and complex application that is worthy of study in its own right. This book tours most of the implementation of <tt>lcc</tt>, a compiler for the ANSI C programming language. It tries to be to compiling what <cite>Software Tools</cite> by B. W. Kernighan and P. J. Plauger (Addison-Wesley, 1976), which tours practical tools for tasks like text editing and macro processing, is to text processing. Software design and implementation are best learned through experience with real tools. This book explains in detail and shows most of the code for a real compiler. The accompanying diskette holds the source code for the complete compiler.</p>
		<p><tt>lcc</tt> is a production compiler, not a toy. It&rsquo;s been used to compile production programs since 1988 and is now used by hundreds of C programmers daily. Detailing most of a production compiler in a book leaves little room for supporting material, so we present only the theory needed for the implementation at hand and leave the broad survey of compiling techniques to existing texts. The book omits a few language features&mdash;those with mundane or repetitive implementations and those deliberately left as exercises&mdash;but the full compiler is available on the diskette, and the book makes it understandable.</p>
		<p>The obvious use for this book is to learn more about compiler construction. But only few programmers need to know how to design and implement compilers. Most work on applications and other aspects of systems programming. There are four reasons why this majority of C programmers may benefit from this book.</p>
		<p>First, programmers who understand how a C compiler works are often better programmers in general and better C programmers in particular. The compiler writer must understand even the darkest corners of the C language; touring the implementation of those corners reveals much about the language itself and its efficient realization on modern computers.</p>
		<p>Second, most texts on programming must necessarily use small examples, which often demonstrate techniques simply and elegantly. Most programmers, however, work on large programs that have evolved&mdash;or degenerated&mdash;over time. There are few well documented examples of this kind of &lsquo;programming-in-the-large&rsquo; that can serve as reference examples. <tt>lcc</tt> isn&rsquo;t perfect, but this book documents both its good and bad points in detail and thus provides one such reference point.</p>
		<p>Third, a compiler is one of the best demonstrations in computer science of the interaction between theory and practice. <tt>lcc</tt> displays both the places where this interaction is smooth and the results are elegant and where practical demands strain the theory, which shows in the resulting code. Exploring these interactions in a real program helps programmers understand when, where, and how to apply different techniques. <tt>lcc</tt> also illustrates numerous C programming techniques.</p>
		<p>Fourth, this book is an example of a &lsquo;literate program.&rsquo; Like <cite>TeX: The Program</cite> by D. E. Knuth (Addison-Wesley, 1986), this book is <tt>lcc</tt>&rsquo;s source code and the prose that describes it. The code is presented in the order that best suits understanding, not in the order dictated by the C programming language. The source code that appears on the diskette is extracted automatically from the book&rsquo;s text files.</p>
		<p>This book is well suited to self-study in both academic and professional settings. The book and its distribution offer complete documented source code for <tt>lcc</tt>, so they may interest practitioners who wish to experiment with compilation or those working in application areas that use or implement language-based tools and techniques, such as user interfaces.</p>
		<p>The book shows a large software system, warts and all. It could thus be the subject of a post-mortem in a software engineering course, for example.</p>
		<p>For compiler courses, this book complements traditional compiler texts. This book shows <em>one</em> way of implementing a C compiler while traditional texts survey algorithms for solving the broad range of problems encountered in compiling. Limited space prevents such texts from including more than a toy compiler. Code generation is often treated at a particularly high level to avoid tying the book to a specific computer.</p>
		<p>As a result, many instructors assign a substantial programming project to give their students some practical experience. These instructors usually must write these compilers from scratch; students duplicate large portions and have to use the rest with only limited documentation. The situation is trying for both and unsatisfying to boot, because the compilers are still toys. By documenting most of a real compiler and providing the source code, this book offers an alternative.</p>
		<p>This book presents full code generators for the MIPS R3000, SPARC, and Intel 386 and successor architectures. It exploits recent research that produces code generators from compact specifications. These methods allow us to present complete code generators for several machines, which no other books do. Presenting several code generators avoids tying the book to a single machine and helps students appreciate engineering retargetable software.</p>
		<p>Assignments can add language features, optimizations, and targets. When used with a traditional survey text, assignments could also replace existing modules with those using alternate algorithms. Such assignments come closer to the actual practice of compiler engineering than assignments that implement most of toy compiler, where too much time goes to low-level infra-structure and accommodating repetitive language features. Many of the exercises pose just these kinds of engineering problems.</p>
		<p><tt>lcc</tt> has also been adapted for purposes other than conventional compilation. For example, it&rsquo;s been used for building a C browser and for generating remote-procedure-call stubs from declarations. It could also be used to experiment with language extensions, proposed computer architectures, and code generator technologies.</p>
		<p>We assume readers are fluent in C and assembly language for some computer, know what a compiler is and have a general understanding of one does, and have a working understanding of data structures and algorithms at the level covered in typical undergraduate courses; the material covered by <cite>Algorithms in C</cite> by R. Sedgewick (Addison-Wesley, 1990), for example, is more than sufficient for understanding <tt>lcc</tt>.</p>
		<hr>
		<address><a href="http://cwfraser.webhop.net">Chris Fraser</a><br>
			<a href="http://drh.home.dyndns.org">David Hanson</a><br>
			$Revision$ $Date$</address>
	</body>

</html>